<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmes de Camins Mínims</title>

    <link rel="alternate" href="https://campusempresa.com/mod/algoritmos_avanzados/03-03-caminos-minimos" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/algoritmos_avanzados/03-03-camins-minims" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/algoritmos_avanzados/03-03-shortest-paths" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-12 col-md-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png"></a>
			</h1>
		</div>
		<div class="col-12 col-md-4 p-0 text-end">
			<h2 id="main_title"><cite>Construint la societat d'avui i del demà</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
							<a href="https://enterprisecampus.net/mod/algoritmos_avanzados/03-03-shortest-paths" class="px-2">EN</a></b>
				|
				<a href="https://campusempresa.com/mod/algoritmos_avanzados/03-03-caminos-minimos" class="px-2">ES</a></b>
				|
				<b class="px-2">CA</b>
											</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">El Projecte</a>
				<a href="/about">Sobre nosaltres</a>
				<a href="/contribute">Contribuir</a>
				<a href="/donate">Donacions</a>
				<a href="/licence">Llicència</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
								<div class='row navigation'>
	<div class='col-2'>
					<a href='03-02-cerca-grafs' title="Cerca en Grafs: BFS i DFS">&#x25C4;Anterior</a>
			</div>
	<div class='col-8 text-center'>
					<a href="./"><h2 style="text-decoration:underline">Algoritmes de Camins Mínims</h2></a>
			</div>
	<div class='col-2 text-end'>
					<a href='03-04-flux-maxim' title="Algoritmes de Flux Màxim">Següent &#x25BA;</a>
			</div>
</div>
<div class='content'><p>En aquest tema, explorarem els algoritmes que ens permeten trobar el camí més curt entre dos nodes en un graf. Aquests algoritmes són fonamentals en moltes aplicacions, com ara la navegació GPS, les xarxes de comunicació i la logística. Ens centrarem en els següents algorismes:</p>
<ol>
<li><strong>Algoritme de Dijkstra</strong></li>
<li><strong>Algoritme de Bellman-Ford</strong></li>
<li><strong>Algoritme de Floyd-Warshall</strong></li>
<li><strong>Algoritme de Johnson</strong></li>
</ol>
</div><h1>1. Algoritme de Dijkstra</h1>
<div class='content'></div><h2>Descripció</h2>
<div class='content'><p>L'algoritme de Dijkstra és un algorisme de recorregut en grafs que troba el camí més curt des d'un node origen a tots els altres nodes en un graf amb pesos no negatius.</p>
</div><h2>Pseudocodi</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("RGlqa3N0cmEoRywgcykKICBwZXIgYSBjYWRhIG5vZGUgdiBlbiBHCiAgICBkaXN0W3ZdIDo9IGluZmluaXQKICAgIGFudGVyaW9yW3ZdIDo9IG5vIGRlZmluaXQKICBkaXN0W3NdIDo9IDAKICBRIDo9IHRvdHMgZWxzIG5vZGVzIGRlIEcKCiAgbWVudHJlIFEgbm8gZXN0aWd1aSBidWl0CiAgICB1IDo9IG5vZGUgZW4gUSBhbWIgZGlzdFt1XSBtw61uaW0KICAgIGVsaW1pbmFyIHUgZGUgUQoKICAgIHBlciBhIGNhZGEgdmXDrSB2IGRlIHUKICAgICAgYWx0IDo9IGRpc3RbdV0gKyBwZXModSwgdikKICAgICAgc2kgYWx0IDwgZGlzdFt2XQogICAgICAgIGRpc3Rbdl0gOj0gYWx0CiAgICAgICAgYW50ZXJpb3Jbdl0gOj0gdQoKICByZXRvcm5hciBkaXN0W10sIGFudGVyaW9yW10="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>Dijkstra(G, s)
  per a cada node v en G
    dist[v] := infinit
    anterior[v] := no definit
  dist[s] := 0
  Q := tots els nodes de G

  mentre Q no estigui buit
    u := node en Q amb dist[u] m&iacute;nim
    eliminar u de Q

    per a cada ve&iacute; v de u
      alt := dist[u] + pes(u, v)
      si alt &lt; dist[v]
        dist[v] := alt
        anterior[v] := u

  retornar dist[], anterior[]</pre></div><div class='content'></div><h2>Exemple</h2>
<div class='content'><p>Considerem el següent graf:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIEEKICAgLyBcCiAgMSAgIDQKIC8gICAgIFwKQi0tLS0tLS1DCiBcICAgICAvCiAgMiAgIDEKICAgXCAvCiAgICBE"))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    A
   / \
  1   4
 /     \
B-------C
 \     /
  2   1
   \ /
    D</pre></div><div class='content'><p>Aplicarem l'algoritme de Dijkstra des del node A.</p>
</div><h2>Implementació en Python</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0KToKICAgIGRpc3QgPSB7bm9kZTogZmxvYXQoJ2luZicpIGZvciBub2RlIGluIGdyYXBofQogICAgZGlzdFtzdGFydF0gPSAwCiAgICBwcSA9IFsoMCwgc3RhcnQpXQogICAgcHJldiA9IHtub2RlOiBOb25lIGZvciBub2RlIGluIGdyYXBofQoKICAgIHdoaWxlIHBxOgogICAgICAgIGN1cnJlbnRfZGlzdCwgY3VycmVudF9ub2RlID0gaGVhcHEuaGVhcHBvcChwcSkKCiAgICAgICAgaWYgY3VycmVudF9kaXN0ID4gZGlzdFtjdXJyZW50X25vZGVdOgogICAgICAgICAgICBjb250aW51ZQoKICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFtjdXJyZW50X25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGRpc3RhbmNlID0gY3VycmVudF9kaXN0ICsgd2VpZ2h0CgogICAgICAgICAgICBpZiBkaXN0YW5jZSA8IGRpc3RbbmVpZ2hib3JdOgogICAgICAgICAgICAgICAgZGlzdFtuZWlnaGJvcl0gPSBkaXN0YW5jZQogICAgICAgICAgICAgICAgcHJldltuZWlnaGJvcl0gPSBjdXJyZW50X25vZGUKICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKHBxLCAoZGlzdGFuY2UsIG5laWdoYm9yKSkKCiAgICByZXR1cm4gZGlzdCwgcHJldgoKZ3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDEsICdDJzogNH0sCiAgICAnQic6IHsnQSc6IDEsICdDJzogMiwgJ0QnOiAyfSwKICAgICdDJzogeydBJzogNCwgJ0InOiAyLCAnRCc6IDF9LAogICAgJ0QnOiB7J0InOiAyLCAnQyc6IDF9Cn0KCmRpc3RhbmNlcywgcHJldmlvdXNfbm9kZXMgPSBkaWprc3RyYShncmFwaCwgJ0EnKQpwcmludCgiRGlzdMOgbmNpZXM6IiwgZGlzdGFuY2VzKQpwcmludCgiTm9kZXMgYW50ZXJpb3JzOiIsIHByZXZpb3VzX25vZGVzKQ=="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    prev = {node: None for node in graph}

    while pq:
        current_dist, current_node = heapq.heappop(pq)

        if current_dist &gt; dist[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_dist + weight

            if distance &lt; dist[neighbor]:
                dist[neighbor] = distance
                prev[neighbor] = current_node
                heapq.heappush(pq, (distance, neighbor))

    return dist, prev

graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 2},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 2, 'C': 1}
}

distances, previous_nodes = dijkstra(graph, 'A')
print(&quot;Dist&agrave;ncies:&quot;, distances)
print(&quot;Nodes anteriors:&quot;, previous_nodes)</pre></div><div class='content'></div><h2>Exercici Pràctic</h2>
<div class='content'><p>Donat el següent graf, aplica l'algoritme de Dijkstra per trobar el camí més curt des del node 'S' a tots els altres nodes:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIFMKICAgL3xcCiAgNyB8IDkKIC8gIHwgIFwKQS0tLUItLS1DCiBcICB8ICAvCiAgMiB8IDQKICAgXHwvCiAgICBE"))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    S
   /|\
  7 | 9
 /  |  \
A---B---C
 \  |  /
  2 | 4
   \|/
    D</pre></div><div class='content'></div><h1>2. Algoritme de Bellman-Ford</h1>
<div class='content'></div><h2>Descripció</h2>
<div class='content'><p>L'algoritme de Bellman-Ford és capaç de trobar el camí més curt des d'un node origen a tots els altres nodes en un graf, fins i tot si aquest conté arestes amb pesos negatius. A més, pot detectar cicles de pes negatiu.</p>
</div><h2>Pseudocodi</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("QmVsbG1hbkZvcmQoRywgcykKICBwZXIgYSBjYWRhIG5vZGUgdiBlbiBHCiAgICBkaXN0W3ZdIDo9IGluZmluaXQKICAgIGFudGVyaW9yW3ZdIDo9IG5vIGRlZmluaXQKICBkaXN0W3NdIDo9IDAKCiAgcGVyIGkgZGUgMSBhIHxWfCAtIDEKICAgIHBlciBhIGNhZGEgYXJlc3RhICh1LCB2KSBlbiBHCiAgICAgIHNpIGRpc3RbdV0gKyBwZXModSwgdikgPCBkaXN0W3ZdCiAgICAgICAgZGlzdFt2XSA6PSBkaXN0W3VdICsgcGVzKHUsIHYpCiAgICAgICAgYW50ZXJpb3Jbdl0gOj0gdQoKICBwZXIgYSBjYWRhIGFyZXN0YSAodSwgdikgZW4gRwogICAgc2kgZGlzdFt1XSArIHBlcyh1LCB2KSA8IGRpc3Rbdl0KICAgICAgZXJyb3IgIkdyYWYgY29udMOpIHVuIGNpY2xlIGRlIHBlcyBuZWdhdGl1IgoKICByZXRvcm5hciBkaXN0W10sIGFudGVyaW9yW10="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>BellmanFord(G, s)
  per a cada node v en G
    dist[v] := infinit
    anterior[v] := no definit
  dist[s] := 0

  per i de 1 a |V| - 1
    per a cada aresta (u, v) en G
      si dist[u] + pes(u, v) &lt; dist[v]
        dist[v] := dist[u] + pes(u, v)
        anterior[v] := u

  per a cada aresta (u, v) en G
    si dist[u] + pes(u, v) &lt; dist[v]
      error &quot;Graf cont&eacute; un cicle de pes negatiu&quot;

  retornar dist[], anterior[]</pre></div><div class='content'></div><h2>Exemple</h2>
<div class='content'><p>Considerem el següent graf amb pesos negatius:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIEEKICAgLyBcCiAgMSAgLTMKIC8gICAgIFwKQi0tLS0tLS1DCiBcICAgICAvCiAgMiAgIDEKICAgXCAvCiAgICBE"))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    A
   / \
  1  -3
 /     \
B-------C
 \     /
  2   1
   \ /
    D</pre></div><div class='content'><p>Aplicarem l'algoritme de Bellman-Ford des del node A.</p>
</div><h2>Implementació en Python</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGJlbGxtYW5fZm9yZChncmFwaCwgc3RhcnQpOgogICAgZGlzdCA9IHtub2RlOiBmbG9hdCgnaW5mJykgZm9yIG5vZGUgaW4gZ3JhcGh9CiAgICBkaXN0W3N0YXJ0XSA9IDAKICAgIHByZXYgPSB7bm9kZTogTm9uZSBmb3Igbm9kZSBpbiBncmFwaH0KCiAgICBmb3IgXyBpbiByYW5nZShsZW4oZ3JhcGgpIC0gMSk6CiAgICAgICAgZm9yIG5vZGUgaW4gZ3JhcGg6CiAgICAgICAgICAgIGZvciBuZWlnaGJvciwgd2VpZ2h0IGluIGdyYXBoW25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgICAgICBpZiBkaXN0W25vZGVdICsgd2VpZ2h0IDwgZGlzdFtuZWlnaGJvcl06CiAgICAgICAgICAgICAgICAgICAgZGlzdFtuZWlnaGJvcl0gPSBkaXN0W25vZGVdICsgd2VpZ2h0CiAgICAgICAgICAgICAgICAgICAgcHJldltuZWlnaGJvcl0gPSBub2RlCgogICAgZm9yIG5vZGUgaW4gZ3JhcGg6CiAgICAgICAgZm9yIG5laWdoYm9yLCB3ZWlnaHQgaW4gZ3JhcGhbbm9kZV0uaXRlbXMoKToKICAgICAgICAgICAgaWYgZGlzdFtub2RlXSArIHdlaWdodCA8IGRpc3RbbmVpZ2hib3JdOgogICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigiR3JhZiBjb250w6kgdW4gY2ljbGUgZGUgcGVzIG5lZ2F0aXUiKQoKICAgIHJldHVybiBkaXN0LCBwcmV2CgpncmFwaCA9IHsKICAgICdBJzogeydCJzogMSwgJ0MnOiAtM30sCiAgICAnQic6IHsnQSc6IDEsICdDJzogMiwgJ0QnOiAyfSwKICAgICdDJzogeydBJzogLTMsICdCJzogMiwgJ0QnOiAxfSwKICAgICdEJzogeydCJzogMiwgJ0MnOiAxfQp9CgpkaXN0YW5jZXMsIHByZXZpb3VzX25vZGVzID0gYmVsbG1hbl9mb3JkKGdyYXBoLCAnQScpCnByaW50KCJEaXN0w6BuY2llczoiLCBkaXN0YW5jZXMpCnByaW50KCJOb2RlcyBhbnRlcmlvcnM6IiwgcHJldmlvdXNfbm9kZXMp"))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def bellman_ford(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    prev = {node: None for node in graph}

    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node].items():
                if dist[node] + weight &lt; dist[neighbor]:
                    dist[neighbor] = dist[node] + weight
                    prev[neighbor] = node

    for node in graph:
        for neighbor, weight in graph[node].items():
            if dist[node] + weight &lt; dist[neighbor]:
                raise ValueError(&quot;Graf cont&eacute; un cicle de pes negatiu&quot;)

    return dist, prev

graph = {
    'A': {'B': 1, 'C': -3},
    'B': {'A': 1, 'C': 2, 'D': 2},
    'C': {'A': -3, 'B': 2, 'D': 1},
    'D': {'B': 2, 'C': 1}
}

distances, previous_nodes = bellman_ford(graph, 'A')
print(&quot;Dist&agrave;ncies:&quot;, distances)
print(&quot;Nodes anteriors:&quot;, previous_nodes)</pre></div><div class='content'></div><h2>Exercici Pràctic</h2>
<div class='content'><p>Donat el següent graf amb pesos negatius, aplica l'algoritme de Bellman-Ford per trobar el camí més curt des del node 'S' a tots els altres nodes:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIFMKICAgL3xcCiAgNyB8IC05CiAvICB8ICBcCkEtLS1CLS0tQwogXCAgfCAgLwogIDIgfCA0CiAgIFx8LwogICAgRA=="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    S
   /|\
  7 | -9
 /  |  \
A---B---C
 \  |  /
  2 | 4
   \|/
    D</pre></div><div class='content'></div><h1>3. Algoritme de Floyd-Warshall</h1>
<div class='content'></div><h2>Descripció</h2>
<div class='content'><p>L'algoritme de Floyd-Warshall és un algorisme per trobar els camins més curts entre tots els parells de nodes en un graf. És especialment útil per a grafs densos.</p>
</div><h2>Pseudocodi</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("RmxveWRXYXJzaGFsbChHKQogIGRpc3QgOj0gYXJyYXkgZGUgfFZ8IHggfFZ8IGluaWNpYWxpdHphdCBhIGluZmluaXQKICBwZXIgYSBjYWRhIG5vZGUgdiBlbiBHCiAgICBkaXN0W3ZdW3ZdIDo9IDAKICBwZXIgYSBjYWRhIGFyZXN0YSAodSwgdikgZW4gRwogICAgZGlzdFt1XVt2XSA6PSBwZXModSwgdikKCiAgcGVyIGsgZGUgMSBhIHxWfAogICAgcGVyIGkgZGUgMSBhIHxWfAogICAgICBwZXIgaiBkZSAxIGEgfFZ8CiAgICAgICAgc2kgZGlzdFtpXVtqXSA+IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdCiAgICAgICAgICBkaXN0W2ldW2pdIDo9IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdCgogIHJldG9ybmFyIGRpc3Q="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>FloydWarshall(G)
  dist := array de |V| x |V| inicialitzat a infinit
  per a cada node v en G
    dist[v][v] := 0
  per a cada aresta (u, v) en G
    dist[u][v] := pes(u, v)

  per k de 1 a |V|
    per i de 1 a |V|
      per j de 1 a |V|
        si dist[i][j] &gt; dist[i][k] + dist[k][j]
          dist[i][j] := dist[i][k] + dist[k][j]

  retornar dist</pre></div><div class='content'></div><h2>Exemple</h2>
<div class='content'><p>Considerem el següent graf:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIEEKICAgLyBcCiAgMSAgIDQKIC8gICAgIFwKQi0tLS0tLS1DCiBcICAgICAvCiAgMiAgIDEKICAgXCAvCiAgICBE"))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    A
   / \
  1   4
 /     \
B-------C
 \     /
  2   1
   \ /
    D</pre></div><div class='content'><p>Aplicarem l'algoritme de Floyd-Warshall.</p>
</div><h2>Implementació en Python</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGZsb3lkX3dhcnNoYWxsKGdyYXBoKToKICAgIG5vZGVzID0gbGlzdChncmFwaC5rZXlzKCkpCiAgICBkaXN0ID0ge25vZGU6IHtub2RlMjogZmxvYXQoJ2luZicpIGZvciBub2RlMiBpbiBub2Rlc30gZm9yIG5vZGUgaW4gbm9kZXN9CiAgICAKICAgIGZvciBub2RlIGluIG5vZGVzOgogICAgICAgIGRpc3Rbbm9kZV1bbm9kZV0gPSAwCiAgICAKICAgIGZvciBub2RlIGluIGdyYXBoOgogICAgICAgIGZvciBuZWlnaGJvciwgd2VpZ2h0IGluIGdyYXBoW25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGRpc3Rbbm9kZV1bbmVpZ2hib3JdID0gd2VpZ2h0CiAgICAKICAgIGZvciBrIGluIG5vZGVzOgogICAgICAgIGZvciBpIGluIG5vZGVzOgogICAgICAgICAgICBmb3IgaiBpbiBub2RlczoKICAgICAgICAgICAgICAgIGlmIGRpc3RbaV1bal0gPiBkaXN0W2ldW2tdICsgZGlzdFtrXVtqXToKICAgICAgICAgICAgICAgICAgICBkaXN0W2ldW2pdID0gZGlzdFtpXVtrXSArIGRpc3Rba11bal0KICAgIAogICAgcmV0dXJuIGRpc3QKCmdyYXBoID0gewogICAgJ0EnOiB7J0InOiAxLCAnQyc6IDR9LAogICAgJ0InOiB7J0EnOiAxLCAnQyc6IDIsICdEJzogMn0sCiAgICAnQyc6IHsnQSc6IDQsICdCJzogMiwgJ0QnOiAxfSwKICAgICdEJzogeydCJzogMiwgJ0MnOiAxfQp9CgpkaXN0YW5jZXMgPSBmbG95ZF93YXJzaGFsbChncmFwaCkKcHJpbnQoIkRpc3TDoG5jaWVzOiIsIGRpc3RhbmNlcyk="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def floyd_warshall(graph):
    nodes = list(graph.keys())
    dist = {node: {node2: float('inf') for node2 in nodes} for node in nodes}
    
    for node in nodes:
        dist[node][node] = 0
    
    for node in graph:
        for neighbor, weight in graph[node].items():
            dist[node][neighbor] = weight
    
    for k in nodes:
        for i in nodes:
            for j in nodes:
                if dist[i][j] &gt; dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 2},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 2, 'C': 1}
}

distances = floyd_warshall(graph)
print(&quot;Dist&agrave;ncies:&quot;, distances)</pre></div><div class='content'></div><h2>Exercici Pràctic</h2>
<div class='content'><p>Donat el següent graf, aplica l'algoritme de Floyd-Warshall per trobar els camins més curts entre tots els parells de nodes:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIFMKICAgL3xcCiAgNyB8IDkKIC8gIHwgIFwKQS0tLUItLS1DCiBcICB8ICAvCiAgMiB8IDQKICAgXHwvCiAgICBE"))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    S
   /|\
  7 | 9
 /  |  \
A---B---C
 \  |  /
  2 | 4
   \|/
    D</pre></div><div class='content'></div><h1>4. Algoritme de Johnson</h1>
<div class='content'></div><h2>Descripció</h2>
<div class='content'><p>L'algoritme de Johnson és una combinació dels algorismes de Bellman-Ford i Dijkstra que permet trobar els camins més curts entre tots els parells de nodes en un graf amb pesos negatius, però sense cicles de pes negatiu.</p>
</div><h2>Pseudocodi</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("Sm9obnNvbihHKQogIGFmZWdpciB1biBub2RlIHEgYSBHIGFtYiBhcmVzdGVzIGRlIHBlcyAwIGEgdG90cyBlbHMgYWx0cmVzIG5vZGVzCiAgaCA6PSBCZWxsbWFuRm9yZChHLCBxKQogIHBlciBhIGNhZGEgYXJlc3RhICh1LCB2KSBlbiBHCiAgICBwZXModSwgdikgOj0gcGVzKHUsIHYpICsgaFt1XSAtIGhbdl0KICBlbGltaW5hciBxIGRlIEcKICBwZXIgYSBjYWRhIG5vZGUgdSBlbiBHCiAgICBkaXN0W3VdIDo9IERpamtzdHJhKEcsIHUpCiAgICBwZXIgYSBjYWRhIG5vZGUgdiBlbiBHCiAgICAgIGRpc3RbdV1bdl0gOj0gZGlzdFt1XVt2XSArIGhbdl0gLSBoW3VdCiAgcmV0b3JuYXIgZGlzdA=="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>Johnson(G)
  afegir un node q a G amb arestes de pes 0 a tots els altres nodes
  h := BellmanFord(G, q)
  per a cada aresta (u, v) en G
    pes(u, v) := pes(u, v) + h[u] - h[v]
  eliminar q de G
  per a cada node u en G
    dist[u] := Dijkstra(G, u)
    per a cada node v en G
      dist[u][v] := dist[u][v] + h[v] - h[u]
  retornar dist</pre></div><div class='content'></div><h2>Exemple</h2>
<div class='content'><p>Considerem el següent graf amb pesos negatius:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIEEKICAgLyBcCiAgMSAgLTMKIC8gICAgIFwKQi0tLS0tLS1DCiBcICAgICAvCiAgMiAgIDEKICAgXCAvCiAgICBE"))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    A
   / \
  1  -3
 /     \
B-------C
 \     /
  2   1
   \ /
    D</pre></div><div class='content'><p>Aplicarem l'algoritme de Johnson.</p>
</div><h2>Implementació en Python</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGJlbGxtYW5fZm9yZChncmFwaCwgc3RhcnQpOgogICAgZGlzdCA9IHtub2RlOiBmbG9hdCgnaW5mJykgZm9yIG5vZGUgaW4gZ3JhcGh9CiAgICBkaXN0W3N0YXJ0XSA9IDAKICAgIHByZXYgPSB7bm9kZTogTm9uZSBmb3Igbm9kZSBpbiBncmFwaH0KCiAgICBmb3IgXyBpbiByYW5nZShsZW4oZ3JhcGgpIC0gMSk6CiAgICAgICAgZm9yIG5vZGUgaW4gZ3JhcGg6CiAgICAgICAgICAgIGZvciBuZWlnaGJvciwgd2VpZ2h0IGluIGdyYXBoW25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgICAgICBpZiBkaXN0W25vZGVdICsgd2VpZ2h0IDwgZGlzdFtuZWlnaGJvcl06CiAgICAgICAgICAgICAgICAgICAgZGlzdFtuZWlnaGJvcl0gPSBkaXN0W25vZGVdICsgd2VpZ2h0CiAgICAgICAgICAgICAgICAgICAgcHJldltuZWlnaGJvcl0gPSBub2RlCgogICAgZm9yIG5vZGUgaW4gZ3JhcGg6CiAgICAgICAgZm9yIG5laWdoYm9yLCB3ZWlnaHQgaW4gZ3JhcGhbbm9kZV0uaXRlbXMoKToKICAgICAgICAgICAgaWYgZGlzdFtub2RlXSArIHdlaWdodCA8IGRpc3RbbmVpZ2hib3JdOgogICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigiR3JhZiBjb250w6kgdW4gY2ljbGUgZGUgcGVzIG5lZ2F0aXUiKQoKICAgIHJldHVybiBkaXN0LCBwcmV2CgpkZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0KToKICAgIGRpc3QgPSB7bm9kZTogZmxvYXQoJ2luZicpIGZvciBub2RlIGluIGdyYXBofQogICAgZGlzdFtzdGFydF0gPSAwCiAgICBwcSA9IFsoMCwgc3RhcnQpXQogICAgcHJldiA9IHtub2RlOiBOb25lIGZvciBub2RlIGluIGdyYXBofQoKICAgIHdoaWxlIHBxOgogICAgICAgIGN1cnJlbnRfZGlzdCwgY3VycmVudF9ub2RlID0gaGVhcHEuaGVhcHBvcChwcSkKCiAgICAgICAgaWYgY3VycmVudF9kaXN0ID4gZGlzdFtjdXJyZW50X25vZGVdOgogICAgICAgICAgICBjb250aW51ZQoKICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFtjdXJyZW50X25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGRpc3RhbmNlID0gY3VycmVudF9kaXN0ICsgd2VpZ2h0CgogICAgICAgICAgICBpZiBkaXN0YW5jZSA8IGRpc3RbbmVpZ2hib3JdOgogICAgICAgICAgICAgICAgZGlzdFtuZWlnaGJvcl0gPSBkaXN0YW5jZQogICAgICAgICAgICAgICAgcHJldltuZWlnaGJvcl0gPSBjdXJyZW50X25vZGUKICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKHBxLCAoZGlzdGFuY2UsIG5laWdoYm9yKSkKCiAgICByZXR1cm4gZGlzdCwgcHJldgoKZGVmIGpvaG5zb24oZ3JhcGgpOgogICAgbmV3X2dyYXBoID0ge25vZGU6IG5laWdoYm9ycy5jb3B5KCkgZm9yIG5vZGUsIG5laWdoYm9ycyBpbiBncmFwaC5pdGVtcygpfQogICAgbmV3X2dyYXBoWydxJ10gPSB7bm9kZTogMCBmb3Igbm9kZSBpbiBncmFwaH0KCiAgICBoLCBfID0gYmVsbG1hbl9mb3JkKG5ld19ncmFwaCwgJ3EnKQoKICAgIGZvciB1IGluIGdyYXBoOgogICAgICAgIGZvciB2IGluIGdyYXBoW3VdOgogICAgICAgICAgICBncmFwaFt1XVt2XSArPSBoW3VdIC0gaFt2XQoKICAgIGRlbCBuZXdfZ3JhcGhbJ3EnXQoKICAgIGRpc3QgPSB7fQogICAgZm9yIHUgaW4gZ3JhcGg6CiAgICAgICAgZGlzdFt1XSwgXyA9IGRpamtzdHJhKGdyYXBoLCB1KQogICAgICAgIGZvciB2IGluIGRpc3RbdV06CiAgICAgICAgICAgIGRpc3RbdV1bdl0gKz0gaFt2XSAtIGhbdV0KCiAgICByZXR1cm4gZGlzdAoKZ3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDEsICdDJzogLTN9LAogICAgJ0InOiB7J0EnOiAxLCAnQyc6IDIsICdEJzogMn0sCiAgICAnQyc6IHsnQSc6IC0zLCAnQic6IDIsICdEJzogMX0sCiAgICAnRCc6IHsnQic6IDIsICdDJzogMX0KfQoKZGlzdGFuY2VzID0gam9obnNvbihncmFwaCkKcHJpbnQoIkRpc3TDoG5jaWVzOiIsIGRpc3RhbmNlcyk="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def bellman_ford(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    prev = {node: None for node in graph}

    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node].items():
                if dist[node] + weight &lt; dist[neighbor]:
                    dist[neighbor] = dist[node] + weight
                    prev[neighbor] = node

    for node in graph:
        for neighbor, weight in graph[node].items():
            if dist[node] + weight &lt; dist[neighbor]:
                raise ValueError(&quot;Graf cont&eacute; un cicle de pes negatiu&quot;)

    return dist, prev

def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    prev = {node: None for node in graph}

    while pq:
        current_dist, current_node = heapq.heappop(pq)

        if current_dist &gt; dist[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_dist + weight

            if distance &lt; dist[neighbor]:
                dist[neighbor] = distance
                prev[neighbor] = current_node
                heapq.heappush(pq, (distance, neighbor))

    return dist, prev

def johnson(graph):
    new_graph = {node: neighbors.copy() for node, neighbors in graph.items()}
    new_graph['q'] = {node: 0 for node in graph}

    h, _ = bellman_ford(new_graph, 'q')

    for u in graph:
        for v in graph[u]:
            graph[u][v] += h[u] - h[v]

    del new_graph['q']

    dist = {}
    for u in graph:
        dist[u], _ = dijkstra(graph, u)
        for v in dist[u]:
            dist[u][v] += h[v] - h[u]

    return dist

graph = {
    'A': {'B': 1, 'C': -3},
    'B': {'A': 1, 'C': 2, 'D': 2},
    'C': {'A': -3, 'B': 2, 'D': 1},
    'D': {'B': 2, 'C': 1}
}

distances = johnson(graph)
print(&quot;Dist&agrave;ncies:&quot;, distances)</pre></div><div class='content'></div><h2>Exercici Pràctic</h2>
<div class='content'><p>Donat el següent graf amb pesos negatius, aplica l'algoritme de Johnson per trobar els camins més curts entre tots els parells de nodes:</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ICAgIFMKICAgL3xcCiAgNyB8IC05CiAvICB8ICBcCkEtLS1CLS0tQwogXCAgfCAgLwogIDIgfCA0CiAgIFx8LwogICAgRA=="))));alert("Copiat!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>    S
   /|\
  7 | -9
 /  |  \
A---B---C
 \  |  /
  2 | 4
   \|/
    D</pre></div><div class='content'></div><h1>Conclusió</h1>
<div class='content'><p>En aquesta secció, hem explorat diversos algorismes per trobar els camins més curts en grafs. Hem après a utilitzar l'algoritme de Dijkstra per a grafs amb pesos no negatius, l'algoritme de Bellman-Ford per a grafs amb pesos negatius, l'algoritme de Floyd-Warshall per a trobar els camins més curts entre tots els parells de nodes, i l'algoritme de Johnson per a grafs amb pesos negatius però sense cicles de pes negatiu. Aquests algorismes són fonamentals en moltes aplicacions pràctiques i ens proporcionen eines poderoses per resoldre problemes complexos en grafs.</p>
</div><div class='row navigation'>
	<div class='col-2'>
					<a href='03-02-cerca-grafs' title="Cerca en Grafs: BFS i DFS">&#x25C4;Anterior</a>
			</div>
	<div class='col-8 text-center'>
			</div>
	<div class='col-2 text-end'>
					<a href='03-04-flux-maxim' title="Algoritmes de Flux Màxim">Següent &#x25BA;</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Publicitat</h1>
			<p>Aquest espai està destinat a publicitat.</p>
			<p>Si vols ser patrocinador, contacta amb nosaltres per incloure enllaços en aquesta zona: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Gràcies per col·laborar!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. Tots els drets reservats</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Acceptar</a>
    <a href="/cookies">Més informació</a>
</div>	

	</div>    
</body>
</html>
